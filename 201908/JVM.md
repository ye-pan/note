## 内存管理

对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好，不过也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机时怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。

### 运行时数据区域

![1565312323387](../assets/1565312323387.png)

#### 程序计数器(Program Counter Register)

一块较小的内存空间，当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。每个线程都有一个独立的程序计数器，各条线成之间计数器互不影响独立存储，这类内存区域为“线程私有”。如果线程执行的时一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器值则为空。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### Java虚拟机栈(Java virtual machine stacks)

生命周期与线程相同，是线程私有的。栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量，操作数栈，动态链接，方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈种入栈到出栈的过程。

局部变量表存放了编译器可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double)，对象引用和returnAddress类型。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配的多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。

StackOverflowError异常，即如果线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError异常，虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存。

#### 本地方法栈(Native method stack)

与Java虚拟机栈类似，不过它是为虚拟机使用到的native方法服务。HotSpot将本地方法栈和虚拟机栈合二为一。

也会抛出StackOverflowError和OutOfMemoryError。

#### Java堆

Java虚拟机所管理的内存种最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域。因为现代JVM的收集器采用的时分代回收策略，所以堆细分为老年代和新生代，新生代有Eden空间，From Survivor空间，To Survivor空间，线程共享的Java堆可能划分出了多个线程私有的分配缓冲区(Thread Local Allocation Buffer)。

Java堆通过-Xmx，-Xms控制大小。OutOfMemoryError，如果在堆种没有内存完成实例分配，并且堆也无法再扩展时。

#### 方法区(Method Area)

与堆一样是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。HotSpot Java7及以前，用堆中永久代来实现的方法区。

Java通过-XX:MaxPermSize来控制大小。OutOfMemoryError，当方法区无法满足内存分配需求时。

#### 运行时常量池(Runtime constant pool)

是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将再类加载后进入方法去的运行时常量池存放。

受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

#### 直接内存(Direct Memory)

Java针对一些场景，需要正在直接再本地进程的堆中分配内存。比如NIO的DirectByteBuffer，可以避免再Java堆和native堆中来回复制数据，显著提高性能。

OutOfMemoryError，受到物理内存的限制，无法动态扩展时抛异常。

#### Java创建对象过程

1. 类加载检查，当遇到new时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过，解析和初始化过。如果没有，就必须先执行相应的类加载过程。
2. 分配内存，对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
3. 初始化零值，JVM需要将分配到的内存空间都初始化为零值
4. 设置对象头
5. 执行init方法

分配内存的方法

* 指针碰撞
* 空闲列表

堆内存分配并发

* CAS+失败重试
* TLAB，为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB的内存已用尽时，上面的方式分配。

### 垃圾收集与内存分配策略

 #### 对象是否可回收

* 引用计数算法，给对象添加一个引用计数器，每当一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器0的对象就是不可能在被使用的
* 可达性分析算法，Java使用可达性分析来判定对象是否存活的，这个算法基本思想就是通过一系列称为“GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象时不可用的。

Java中可作为GC Roots的对象包括：

* 虚拟机栈中引用的对象，
* 方法区中类静态属性引用的对象，
* 方法区中常量引用的对象，
* 本地方法栈中JNI引用的对象。

生存还是死亡：

即使再可达性分析算法中不可达的对象，也并非是”非死不可“的，这时候它们处于”缓刑“阶段，要真正宣告一个对象死亡，至少要经历两次标记过程，如果对象再进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则没必要执行。

方法区回收：

永久代的垃圾回收主要包括：废弃常量和无用的类。

判断是否无用的类，必须同时满足3个条件：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

#### Java中的引用

* 强引用，程序代码中普遍存在的类似”Object o = new Object()“这类直接赋值的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用，描述一些还有用但并非必须的对象。对于软引用关联着的对象，再系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果第二次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference。
* 弱引用，描述非必须对象，但是它的强度比SoftReference更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集工作时无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference。
* 虚引用，也被称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference。

#### 垃圾收集算法

* 标记-清除算法(Mark-Sweep)，标记->清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。两个不足：效率问题，标记和清除两个过程的效率都不高；空间问题，标记清除过后会产生大量不连续的内存碎片，空间碎片太多可能导致以在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
* 复制算法，为了解决效率问题，复制算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是堆整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。现在的商业虚拟机都采用这种收集算法来回收新生代。
* 标记-整理算法(Mark-Compact)，复制算法在对象存货率较高时就要进行较多的复制操作，效率将会变低。根据老年代提出了标记-整理算法。分为标记整理两个过程，整理过程是将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
* 分代收集算法，就是根据对象存活周期，将Java堆分为新生代和老年代。这样根据各个年代的特点采用适当的收集算法，在新生代每次垃圾收集时都发现有大批对象死去，只有少量存活那就选用复制算法。而老年代中因为对象存货率高，没有额外空间对象进行分配担保，就必须使用”标记-整理“或者”标记-清除“算法来进行回收。

HotSpot中新生代的回收，将新生代分为了Eden，From Survivor，To Survivor三块空间按8：1：1分配。每次使用Eden和其中一块Survivor，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。这样实际上在HotSpot的新生代中我们可用的呢次空间为整个新生代的90%。如果出现新生代留下的对象超过10%这种情况，一块Survivor就不够存放，这是需要依赖其它内存(老年代)进行担保分配。

#### HotSpot的算法实现

1. 枚举根节点GC Roots
2. 安全点
3. 安全区域

#### 垃圾收集器

1. Serial收集器
2. ParNew收集器
3. Parallel Savenge收集器
4. Serial Old收集器
5. Parallel Old收集器
6. CMS收集器
7. G1收集器

#### 内存分配与回收策略

* 

## 类文件

### 类加载

虚拟机吧描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类加载过程：

* 加载
* 连接
  * 验证
  * 准备
  * 解析
* 初始化
* 使用
* 卸载

加载，当对一个类进行主动引用时，触发类加载：

* 遇到new, getstatic, putstatic或invokestatic这4条字节码指令时，如果没有进行过初始化，则需要先触发其初始化。使用这4条指令的常见场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段以及调用一个类的静态方法的时候。
* 通过reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发父类的初始化
* 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
* 当使用1.7的动态语言支持时，

这5种场景被称为主动引用，其它所有引用类的方式都不会触发初始化，成为被动引用。被动引用的几个例子：1）通过字类引用父类的静态字段，不会导致子类初始化；2）通过数组来定义引用类，不会触发此类的初始化。数组类本身不通过类加载创建，它是由Java虚拟机直接创建的；3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

加载阶段需要完成3件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口



验证，确保class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自生的安全。

验证阶段的校验动作：

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

如果所运行的全部代码都已经被反复使用验证过，那么在实施阶段可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。



准备，正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量，被static修饰的变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况下”是数据类型的零值，如果是常量final修饰，则会初始化为实际的值。



解析，是虚拟机将常量池的符号引用替换为直接引用的过程，



初始化，到了初始化阶段，才真正开始执行类中定义的Java程序代码。

初始化阶段就是执行类构造器<client>()方法的过程，

* 类构造方法是由编译器自动收集类中的所有类变量的复制动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量在前面的静态语句块可以赋值，但是不能访问。
* 类构造器方法不需要显示的调用父类的构造器，虚拟机会保证在子类的构造器方法执行之前，父类的构造器方法已经执行完毕，因此虚拟机中第一个被执行的构造器方法肯定是Object的
* 父类中定义的静态语句块要优先于子类的变量赋值操作
* 类构造方法对于类或接口来说并不是必需的，如果一个类没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成该方法
* 接口中不能用静态语句块，但仍然由变量初始化的赋值操作，因此接口与类一样都会生成类构造方法，但接口与类不同的是，执行接口的构造器方法不需要先执行父接口的构造器方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外接口的实现类在初始化时也一样不会执行接口的构造器方法。
* 虚拟机会保证一个类的构造器方法在多线程环境中被正确的加锁，同步，如果多个线程同事去初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行该方法完毕。如果一个类的类构造器方法有耗时很长的操作，就可能造成多个进程阻塞。

### 类加载器

类加载器实现类的加载动作，对于任意一个类，都需要由加载器和这个类本身一同确立其在Java虚拟机中的唯一性。

3种系统提供的类加载器：

* 启动类加载器，bootstrap ClassLoader，这个类加载器负责将存放在<JAVA_HOME>/lib目录种的，或者被-Xbootclasspath参数所指定的路径中并且时虚拟机识别的类库加载到虚拟机种。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要吧加载请求委派给引导类加载器。
* 扩展类加载器，Extension ClassLoader，这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>/lib/ext目录种的，或者被java.ext.dirs系统变量所指定的路径中的所有类库
* 应用程序类加载，Application ClassLoader，这个类加载器由sun.misc.Launcher$AppClassLoader实现，这个类加载器是ClassLoader种的getSysteClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径ClassPath上所指定的类库。

双亲委派模型工作流程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器种，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载

## 参考

* 《深入理解Java虚拟机》