## MySQL服务

> 存储引擎

* InnoDB  MySQL默认事务型存储引擎，被设计用来处理大量短期事务。采用MVCC支持高并发，实现了4个标准的隔离级别，默认级别为REPEATABLE READ，通过间隙锁策略防止幻读。
* MyISAM 
* memory

> 转换表的存储引擎

* alter table table_name engine = InnoDB;
* 导出->导入
* create table new_engine_table like old_engine_table;

​       alter table new_engine_table engine=new_engine;

​       insert into new_engine_table select * from old_engine_table; 

### 数据类型

* 更小的通常更好，占用更少的磁盘，内存和CPU缓存，处理时需要的CPU周期也更少
* 简单就好，简单的数据类型的操作通常需要更少的CPU周期
* 尽量避免NULL

### scheme

* 太多的列
* 太多的关联
* 全能的枚举
* 变相的枚举
* 非此发明的NULL

### 范式和反范式

范式：

* 范式化的更新操作通常比反范式化要快
* 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
* 范式化的表通常更小，可以更好的放在内存中，所以执行操作会更快
* 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句

> 范式化设计的缺点时通常需要关联，稍微复杂一些的查询语句在符合范式的scheme上都可能需要至少一次关联。

反范式：

* 反范式化的schema因为所有数据都在一张表中，可以很好的避免关联
* 单独的表也能使用更有效的索引策略

> 如果不需要关联表，则对大部分查询最差的情况，即使表没有使用索引——使用全表扫描，当数据比内存大时这可能比关联要快的多，因为这样避免了随机IO。
>
> 全表扫描基本上时顺序IO，但也不是100%的，跟引擎的实现有关。

> 更快的读，更慢的写。为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但显著的提高了读操作的性能。

## 索引

索引类型

B-Tree

限制：

* 如果不是按照索引的最左列开始查找，则无法使用索引
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

哈希索引

限制：

* 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
* 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
* 哈希索引只支持等值比较查询，包括=，in()，<=>，不支持任何范围查询
* 访问哈希索引的数据非常快，除非有很多哈希冲突
* 如果哈希冲突很多的话，一些索引维护操作的代价也会很高

> 因为这些限制，哈希索引只适用于某些特定的场合，而一旦适合哈希索引，则它带来的性能提升非常显著。
>
> InnoDB引擎有一个特殊的功能叫做自适应哈希索引，当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引，这样就让B-Tree索引也具有一些哈希索引的优点了。

空间数据索引



全文索引，他查找的时文本中的关键词，而不是直接比较索引中的值，全文索引适用于MATCH AGAINST操作，而不是WHERE条件操作。



索引的优点：

* 索引大大减少了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机IO变为顺序IO

索引是独立的列，索引列不能是表达式的一部分，也不能是函数的参数

索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：

* 当出现服务器对多个索引做相交操作时（通常多个AND），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
* 当服务器需要对多个索引做联合操作时（通常多个OR），通常需要消耗大量CPU和内存资源在算法的缓存，排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候
* 更重要的是，优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。

## 查询

查询优化的是响应时间，如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行的更快。

最简单的衡量查询的3个指标：1.响应时间，2.扫描的行数，3.返回的行数

SQL->查询缓存->解析器->解析树->预处理器->解析树->查询优化器->查询执行计划->查询执行引擎->存储引擎->查询缓存->返回

## 附录.A MySQL

MySQL官方有个自带的测试数据库，叫employees，超过30W用户数据。

具体参考：https://github.com/datacharmer/test_db