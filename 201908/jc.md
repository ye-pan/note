# Java并发

## Java内存模型

Java内存模型用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让程序在各种平台下都能达到一致的内存访问效果。主要定义程序中各个变量的访问规则，即再虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。包括，实例字段，静态字段和构成数组对象的元素，不包括局部变量与方法参数，这是线程私有的。

Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

JMM定义的8种操作，用于变量在主内存和工作内存之间同步：

* lock：作用于主内存，把一个变量标识为一条线程独占
* unlock：作用于主内存，把处于锁定状态的变量释放出来
* read：作用于主内存，把一个变量从主内存传输到线程的工作内存中
* load：作用于工作内存，把read操作得到的变量值放入工作内存的变量副本中
* use：作用于工作内存，把工作内存中一个变量值传递给执行引擎
* assign：作用于工作内存，把从执行引擎接收到的值赋给工作内存的变量
* store：作用于工作内存，把工作内存中一个变量值传送到主内存中
* write：作用于主内存，把store操作从工作内存中得到的变量值放入主内存中



读：主内存->read->load->工作内存->use->执行引擎

写：执行引擎->assign->工作内存->store->write->主内存

### volatile型变量的特殊规则

volatile是Java虚拟机提供的轻量级同步机制：

- 保证此变量对所有线程可见性，任何线程对该变量的修改对所有线程立即可见
- 禁止指令重排序优化