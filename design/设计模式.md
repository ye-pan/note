# 设计模式

## 创建型模式

### Abstract Factory 抽象工厂

意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体的类。

适用性：

- 一个系统要独立与它的产品的创建，组合和表示时。
- 一个系统要由多个产品系列中的一个来配置时。
- 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
- 当你提供一个产品类库，而只想显示他们的接口而不是实现时。 

效果：

1. 它分离了具体的类
2. 它使得易于交换产品系列
3. 它有利于产品的一致性
4. 难以支持新种类的产品

### Builder 生成器

意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

适用性：

- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时
- 当构造过程必须允许被构造的对象有不同的表示时

效果：

1. 它使你可以改变一个产品的内部表示
2. 它将构造代码和表示代码分开
3. 它使你可对构造过程经行更精细的控制

### Factory Method 工厂方法

意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类

适用性：

- 当一个类不知道它所必须创建的对象的类的时候
- 当一个类希望由它的子类来指定它所创建的对象的时候
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

效果：

1. 工厂方法不再将与特定应用有关的类绑定到代码中
2. 工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的对象，就不得不创建一个子类
3. 为子类提供了挂钩
4. 连接平行的类层次

### Prototype 原型

意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

适用性：

- 当一个系统应该独立于它的产品创建，构成和表示时，可以使用Prototype模式
- 当要实例化的类是在运行时刻指定时，例如，通过动态加载
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时

效果：

1. 对客户隐藏了具体的产品类，因此减少了客户之道的名字的数目，使得客户无需改变即可使用与特定应用相关的类
2. 运行时刻增加和删除产品
3. 改变值以指定新对象
4. 改变结构以指定新对象
5. 减少子类的构造，相对于抽象工厂来说
6. 用类动态配置应用

### Singleton 单例

意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点

适用性：

- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它
- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展时

效果：

1. 对唯一实例的受控访问
2. 缩小名字空间
3. 允许对操作和表示的精华
4. 允许可变数目的实例
5. 比类操作更灵活

## 结构型模式

### Adapter 适配器

意图：将一个类的即可转换成客户希望的另外一个接口，adapter使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。别名，Wrapper 包装器。

适用性：

- 你想使用一个已经存在的类，而它的接口不符合你的需求
- 你想创建一个可以复用的类，该类可以与其他不想关的类或不可预见的类协同工作
- 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

效果：

1. 用一个具体的adapter类对adaptee和target进行匹配
2. 使得adapter可以重定义adaptee的部分行为
3. 仅仅引入了一个对象，并不需要额外的指针以间接得到adaptee
4. 允许一个adapter与多个adaptee同时工作
5. 使得重定义adaptee的行为比较困难

### Bridge 桥接

意图：将抽象部分与它的实现部分分离，是他们都可以独立地变化

适用性：

- 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。
- 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充
- 对一个抽象的实现部分的修改应对客户不产生影响
- 你想在多个对象间共享实现，但同时要求客户不知道这一点

效果：

1. 分离接口及其实现部分
2. 提高可扩充性
3. 实现细节对客户透明

### Composite 组合

意图：将对象组合成树形结构以表示“部分-整体”的层次结构，Composite使得用户对单个对象和组合对象使用具有一致性。

适用性：

- 你想表示对象的部分-整体层次结构
- 你希望用户忽略组合对象与单个对象的不同，用户将同意地使用组合结构中的所有对象

效果：

1. 定义了包含基本对象和组合对象的层次结构
2. 简化客户代码，客户可以一致的使用组合结构和单个对象。
3. 使得更容易增加新型类型的组件，新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起工作，客户程序不需要因新的Component类而改变。
4. 使你的设计变得更加一般化，容易增加新组建也会产生一些问题，那就是很难限制组合中的组件。

### Decorator 装饰

意图：动态的给一个对象添加一些额外的职责，就增加功能来说，Decorator模式相比生成子类更为灵活

适用性：

- 在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责
- 处理那些可以撤销的操作
- 当不能采用生成子类的方法进行扩充时。

效果：

1. 比静态继承更灵活
2. 避免在层次结构高层的类有太多的特征
3. Decorator与它的Component不一样，Decorator是一个透明的包装
4. 有许多小对象

### Facade 外观

意图：为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口这个接口使得这一子系统更加容易使用

适用性：

- 当你要为一个复杂子系统提供一个简单接口时
- 客户程序与抽象类的实现部分之间存在很大的依赖性
- 当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点

效果

1. 他对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便
2. 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的
3. 如果应用需要，它并不限制他们使用子系统类

### Flyweight 享元

意图：运用共享技术有效的支持大量细粒度的对象

适用性：

- 一个应用程序使用了大量的对象
- 完全由于使用大量的对象，造成很大的存储开销
- 对象的大多数状态都可变为外部状态
- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象
- 应用程序不依赖于对象标识。

效果：

1. 节约了大量由于产生对象产生的内存开销

### Proxy 代理

意图：为其他对象提供一种代理以控制对这个对象的访问

适用性：

- 远程代理，为一个对象在不同的进程空间提供局部代表。
- 虚代理，根据需要创建开销很大的对象，通过代理该对象进行延迟初始化
- 保护代理，控制对原始对象的访问
- 只能指针，取代了简单指针，它在访问对象时执行一些附加操作，比如引用计数

效果：

1. Proxy模式在访问对象时引入了一定程度的间接性
2. Remote Proxy 可以隐藏一个对象存在不同地址空间的事实
3. Virtual Proxy 可以进行最优化，例如根据要求创建对象
4. Protection Proxied和Smart Reference，都允许在访问一个对象时有一些附加的内务处理

## 行为模式

### Chain Of Responsibility 职责链

意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

适用性：

- 有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
- 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
- 可处理一个请求的对象集合应被动态指定

效果：

1. 降低耦合度，该模式使得一个对象无需知道时其他哪一个对象处理其请求
2. 增强了给对象指派职责的灵活性，挡在对象中分派职责时，职责链给你更多的灵活性
3. 不保证被接受，既然一个请求没有名确的接收者，那么就不能保证它一定会被处理——该请求可能一直到链的末端都得不到处理。

### Command 命令

意图：将一个请求封装为一个对象，从而是你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

适用性：

- 抽象出待执行的动作以参数化某对象
- 在不同的时刻执行，排列和执行请求
- 支持取消操作
- 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍
- 用构建在原语操作上的高层操作构造一个系统。

效果：

1. 将调用操作的对象与知道如何实现该操作的对象解耦
2. Command时头等的对象，它们可以像其它的对象一样被操纵和扩展
3. 你可以将多个命令装配成一个复合命令
4. 增加新的Command很容易，因为者无需改变已有的类

### Interpreter 解释器

意图：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

适用性：

- 当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树，可使用解释器模式
- 该文法简单，对于复杂的文法，文法的类层次变得庞大而无法管理，此时语法分析程序生成器这样的工具是更好的选择
- 效率不是一个关键问题，最高效的解释器通常不是通过直接解析语法分析树实现的，而实首先将他们转换为另一种形式。

效果：

1. 易于改变和扩展文法
2. 也易于实现文法
3. 复杂的文法难以维护
4. 增加了新的解释表达式的方式

### Iterator 迭代器

意图：提供一种顺序访问一个集合对象中各个元素，而又不需暴露该对象的内部表示

适用性：

- 访问一个集合对象的内容而无需暴露它的内部表示
- 支持对集合对象的多种遍历
- 为遍历不同的聚合结构提供一个统一的接口

效果：

1. 它支持以不同的方式遍历一个集合
2. 迭代器简化了集合的接口
3. 在同一个集合上可以有多个遍历

### Mediator 中介者

意图：当一个中介对象来封装一些列的对象交互，中介者使各对象不需要显示的互相吸引，从而使其耦合松散，而且可以独立地改变它们之间的交互

适用性：

- 一组对象以定义良好但复杂的方式进行通信，产生的互相依赖关系结构混乱且难以理解
- 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类

效果：

1. 减少了子类生成
2. 他将各Colleague解耦
3. 它简化了对象协议
4. 它对对象如何协作进行了抽象
5. 它使控制集中化

### Memonto 备忘录

意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态

适用性：

- 必须保存一个对象在某一个时刻的状态，这样以后需要时它才能恢复到先前的状态
- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性

效果：

1. 保持封装边界
2. 它简化了原发器
3. 使用备忘录可能代价很高
4. 定义窄接口和宽接口
5. 维护备忘录的潜在价值

### Observer 观察者

意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被更新

适用性：

- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这二者封装在独立的对象中以使它们可以各自独立地改变和复用
- 当对一个对象地改变需要同时改变其它对象，而不知道具体有多少对象有待改变
- 对一个对象必须通知其它对象，而它又不能假定对象是谁，换言之，你不希望这些对象是紧密耦合的

效果：

1. Observer模式允许你独立的改变目标和观察者，你可以单独复用目标独享而无需同时复用观察者，反之亦然，它也可以使你在不改动目标和其他的观察者前提下增加观察者
2. 目标和观察者间的抽象耦合
3. 支持广播通信
4. 意外更新

### State 状态

意图：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类

适用性：

- 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。

效果：

1. 他将与特定状态相关的行为局部化
2. 它使得状态转换显示化
3. State对象可被共享

### Strategy 策略

意图：定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换，本模式使得算法可独立于使用它的客户而变化

适用性：

- 许多相关的类仅仅是行为有异
- 需要使用一个算法的不同变体
- 算法使用客户不应该知道的数据
- 一个类定义了多种行为

效果：

1. 相关算法系列
2. 一个替代继承的方法
3. 消除了一些条件语句
4. 实现的选择
5. 客户必须了解不同的strategy
6. Strategy和Context之间的通信开销
7. 增加了对象的数目

### Template Method 模板方法

意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

适用性：

- 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
- 控制子类扩展

效果：

1. 模板方法导致一种反向的控制结构，指一个父类调用一个子类的操作。

### Visitor 访问者

意图：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

适用性：

- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作污染这些对象的类
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作

效果：

1. 访问者模式使得易于增加新的操作
2. 访问者集中相关的操作而分离无关的操作
3. 增加新的ConcreteElement类很困难
4. 通过类层次进行访问
5. 累计状态
6. 破坏封装

## 读《设计模式》

第三次读，断断续续读了几天时间，收获比之前两次都大。也是时候放下一段时间，需要在代码中来巩固了，如果遇到不熟悉的地方在回味吧。 后面还会不断地完善这个记录，争取里面都会是自己的理解，而不是书中的摘抄。