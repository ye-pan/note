# 实现模式

程序员为不断重复的琐事耗费的时间越少，他们就有越多的时间来解决好真正独一无二的问题，从而更高效的编程。

绝大多数程序都遵循一组简单的法则：

- 跟多的时候，程序是在被阅读，而不是被修改
- 没有“完工”一说。修改程序的投入会远大于最初编写程序的投入
- 程序都由一组基本的语句和控制流概念组合而成
- 程序的阅读者需要理解程序——即从细节上，也从概念上。有时他们从细节开始，逐渐理解概念； 有时他们从概念开始逐渐理解细节。

## 一种编程理论

### 价值观

#### 读书笔记

1. 沟通，如果阅读者可以理解某段代码，并且进一步修改或使用它，那么这段代码的沟通效果就很好。 在编程时，我们很容易从计算机的角度进行思考，但只有一面编程一面考虑其他人的感受，我才能编写出好 的代码。
2. 简单，去掉复杂性可以让那些阅读，使用和修改代码的人更容易理解。在各个层次上都应当要求简单， 对代码进行调整，删除所有不提供信息的代码，设计中不出现无关元素。对需求提出质疑，找出最本质的概念。 沟通和简单通常都是不可分割的，多余的复杂性越少，系统就越容易理解；在沟通方面投入的越多， 就越容易发现应该被抛弃的复杂性。不过有时候我也会发现某种简化会使程序难以理解， 这种情况下我会优先考虑沟通这样的情形很少，但常常都表示这里应该有一些我尚未察觉的更大规模的简化。
3. 灵活，是衡量那些低效编码与设计实践的一把标尺。程序是应该灵活，但只有在发生变化的时候才需如此。 想象中明天或许会用的上的灵活性，可能与真正修改代码时所需要的灵活性不是一回事。这就是简单性和大规 模测试所带来的灵活性比专门设计出来的灵活性更为有效的原因。要选择那些提倡灵活性并能够带来及时收益 的模式。增进软件的沟通效果同样也会提高灵活性，能够快速阅读，理解和修改你代码的人越多，它将来发生 变化的选择就越多！

文学编程：程序应该读起来像一本书一样，它需要有情节和韵律，句子间应该有优雅的小小跌宕起伏。

#### 个人总结

沟通，简单，灵活就是我们coder的价值观。沟通能力强并不是侃大山牛逼，而是需要我们从最根本的想法上， 要站在他人的角度去看待事情，去coding。在写下这段代码时，我们是否考虑过以后看到这段代码的人的想法 （包括未来的自己）。写出可读性很高的代码就是我们coder间最好的沟通方式。读到后面发现， 这里说的沟通指的应该是通过代码来沟通！

写简单的，贴近业务逻辑的代码，这个功能的代码描述不应该出现除这块功能以外的其他的代码。 随着我们对业务的理解，我们对这块功能的理解，可能和昨天写下这段代码时的理解时不一样的， 这是后就要带上重构的帽子，让这段代码变得简单而不是为了实现当前的功能而在已有的代码上缝缝补补！ 最重要的，理解需求，明白需求下最本质的问题，抓住问题的本质，再考虑这个需求的设计是否合理， 是否有更好的解决方案！

不要以灵活性为借口，将coding变成了单纯的炫技。功能往往只有在经过线上的迭代，经过用户的使用， 最后我们可能才会知道到底哪里需要灵活。不要刻意为了明天的灵活性，而增加今天代码的复杂度。 只有当这里增加的灵活性能够切实的为我们带来业务价值，这个才是值得的！

### 原则

#### 读书笔记

1. 局部化影响，组织代码结构时，要保证变化智慧产生局部化的影响。如果这里的一个变化会引出那里的一 个问题，纳闷变化的代价就会急剧上升了，把影响范围缩到最小，代码就会有极佳的沟通效果。它可以被逐步 深入理解，不必一开始纪要鸟瞰全景。因为实现模式背后一条最主要的动机就是减少变化所引起的代价，所以 局部化影响这条原则也是很多模式的形成缘由之一！
2. 最小化重复，最小化重复这条原则有助于保证局部化影响，如果相同的代码出现在很多地方， 那么改动其中一处副本，就不得不考虑是否需要修改其他副本，变动不再只发生在局部。代码复制的越多， 变化的代价就越大。复制代码，并行的类层次结构都是重复的一种形式。重复不容易被预见到， 有时在出现以后一段时间才会被察觉，重复不是罪过，他只是增加了变化的开销。我们可以把程序拆分成许多 更小的部分——小段语句，小段方法，小型对象和小型包，从而消除重复。大段逻辑很容易与其他大段逻辑出现 重复地代码片段，于是就有了模式诞生地可能。
3. 将逻辑与数据绑定，局部化影响地必然结果就是将逻辑与数据捆绑，把逻辑与逻辑所处理地数据放在一起， 如果有可能，尽量放到一个方法中，或者退一步，放到一个对象里，最起码也要放到一个包下面，在发生变化时， 逻辑和数据可能会同时被改动。如果它们被放在一起，那么修改他们所造成地影响就会只停留在局部。
4. 对称性，程序中处处充满了对称性，比如add()方法总会伴随着remove()方法，一组方法会接受同样地参数， 一个对象中所有的字段都具有相同的声明周期。识别出对称性，把它清晰的表述出来，代码将更容易阅读，一旦 阅读者理解了对称性所涵盖的某一半，他们就很快地理解另外一半。在准备消灭重复之前，常常需要寻找并表示出 代码中的对称性，如果在很多代码中都存在类似的想法，那么可以先把他们用对称的方式表示出来，让接下来的 重构有一个良好的开端。
5. 声明表达式，尽可能声明式的表达出意图，命令式的编程语言功能强大灵活，但是在阅读时需要跟随代码的执 行流程，我必须在大脑中建起一个程序状态，控制流和数据流的模型。对于那些只是陈述简单事实，不需要一系列 条件语句的程序片段，如果用简单的声明式写出来，读着就容易多了。
6. 变化率，把具有相同变化率的逻辑，数据放在一起，把具有不同变化率的逻辑，数据分离。变化率具有时间上的 对称性，有时候可以将变化率原则应用于人为的变化。

#### 个人总结

原则这一章，总体看来已经很贴近我们日常编程了，这几点原则也是可以直接运用于实际开发中，帮助我们组织程 序，代码及类结构。《重构》中的代码的坏味道一章，很多观念和这里不谋而合，可能时因为时同一个作者的缘故。 但从中我们可以看见，这些真的时作者的经验之谈了，每个可以讨论的促进编程手艺的场合，他都在传播这些经验。

其中，局部化影响，很容易理解，同时也是我们平时开发时所期望的。需求是会随着时间以及应用场景的变化而变化 的，我们能做的是期望能够在真正修改时，能够只改动相关功能涉及的代码。最小化重复，就更不多说，重复时开发 的万恶之源，DRY早已深入人心。4，5，6现在的我没有很深刻的体验。

## 动机

### 读书笔记

软件设计的底层驱动力是经济学，软件设计应该致力于减少整体成本，软件成本可以被分解为初始成本（开发） 和维护成本。软件的维护成本要远远高于它的初始成本。维护的代价很大，这是因为理解现有代码需要花费时间， 而且容易出错。知道了需要修改什么以后，做出改动就变得轻而易举了，掌握现在的代码做了哪些事情是需要花 费人力物力的部分，改动之后，还要进行测试和部署。

减少整体成本的策略之一是在初期的开发中投入更多精力，希望借此减少甚至消除维护的需要。这些做法往往会 失败。一旦代码以未预期的方式发生变化，人们曾经所作出的任何预见都不再是万全之策，人们可能会为了预备 将来发生的变化而过早考虑代码的通用性，但如果出现了没有预料到而又势在必行的变化，先前的做法往往就会 与现实发生冲突。

从本质上看，增加软件的先期投入是与两条重要的经济学原则——金钱的时间价值和未来的不确定性，相悖的! 今天的一元钱比明天的一元钱更值钱，所以从原则上讲，我们的实现策略应该是尽量将支出推后，同样由于不 确定性的存在，实现策略应该更倾向于带来及时收益而非长远收益。一方面着眼于获得及时收益，另一方面也 在创建干净的代码，以方便将来的开发工作。

用来减少整体成本的策略是，所有开发人员在进行维护的时候注重程序员与程序员之间的沟通，减少理解代码 所带来的代价。清晰明确代码会带来及时收益：代码缺陷更少，更易共享，开发曲线更加平滑。

### 个人总结

代码来自于人，服务于人。软件的维护成本要远远大于开发成本，我们只有通过及时的沟通并理解对应维护的功 能点，才可能尽力减少维护这个功能的成本。别忘了前面的价值观——沟通，沟通在代码中，所以写出可读性很高 的代码也很重要。还有，应该避免为了明天的灵活性，而在今天的代码中加入过多的预见性代码，这是很不划算 的，在大大的增加了今天设计开发的工作任务同时，可能我们对于明天的预见是错误的，而一旦在明天得到证实 ，那么我们今天设计全都是无用功！

## 类

### 读书笔记

面向对象编程把程序划分成许多类，类是对一组相似的东西的一般归纳，而对象则是这些东西本身。类对于沟通很 重要，因为他们可以描述很多具体的东西。实现模式最大的跨度只到类一级。

1. 类：数据的变化比逻辑要频繁的多，正是这种现象让类有了存在的意义，每个类其实就是这样一个声明：这些逻辑 应该放在一起，他们的变化不想他们所操作的数据那么频繁，这些数据也应该放在一起，他们变化的频率差不多， 并且由与之关联的逻辑来负责处理。学会如何用类来包装逻辑和如何表达逻辑的变化，这是有效使用对象编程的重 要部分。在由对象搭建而成的程序中，类是相对昂贵的设计元素。一个类应该做一些有直接而明显的意义的事情。 减少类的数量是对系统的改进，只要剩下的类不因此而变得臃肿就好。
2. 简单的超类名：找到一个贴切的名字是编程中最令人开心的时刻之一，贴切的名字能引发连锁反应，带来更深入的 简化与改进。类名的“简短”与“表现力”之间存在张力。有时候需要强迫自己找到一个好名字，抽出一本辞典，写下 所有多少有些接近的名字，站起来走一走，另一些时候应该带着挫败感和对时间的信息先去考虑新功能的实现，潜 意识会默默起作用的。交谈总能帮助我想出更好的名字，要尝试把一个类的用途解释给别人听，我就的寻找具有表 现力和感染力的图景来描述它，这样的图景往往能引出新的名字。对于重要的类，尽量用一个单词来为它命名。
3. 限定性的子类名：子类的名字有两重职责，不仅要描述这些类像什么，还要说明它们之间的区别是什么。同样在 这里需要权衡长度与表现力，与位于继承体系根上的超类不同，子类的名字在交谈中用的并不频繁，所以值得以 牺牲简明来换取更好表现力。如果继承只是用作共享实现的机制，并且子类本身就代表一个重要的概念，那么这样 的子类就应该被视为他自己的继承体系的根，拥有一个简单的名字。不要不假思索的在直接超类的基础上扩展出 子类名，要多从阅读者的角度来想想阅读者需要了解这个类的什么信息，应该带着这个思考，以超类名为参考来给 子类命名。
4. 抽象接口：针对接口编程，不要针对实现编程。从另一个角度来说，这也意味着设计决策不应该暴露给不必要的地方 。并不是接口数量越多软件成本就会越少，只有需要接口带来灵活性时才值得为它付出成本。引入接口时的另一个经 济方面的考量是软件的不可预测性。为什么我们不能一次列出系统中所有需要灵活性的地方呢？因为需求和技术都在 以不可预测的方式变化。
5. interface：用Java表达，这是我要完成的任务，除此之外的细节不归我操心，可以声明一个interface。interface 是一个很好的平衡，他带来了多继承的一部分灵活性，同时又没有多继承复杂性和二义性。如果说interface让改变 的工作更加轻松，那么不能不提的就是对接口本身的修改是不被鼓励的，一旦在interface上增加或者修改方法，就 必须同时改变所有的实现类，如果无权改变实现，大量使用interface会严重拖累日后的设计调整。
6. 抽象类：Java中区分抽象接口与具体实现的另一种方式是使用超类。何时应该使用超类 合适应该使用interface？ 取舍最终归结为两点：接口会如何变化，实现类是否需要同时支持多个接口。抽象接口需要支持实现的变化以及接口 本身的变化两种类型的变化。Java的interface对后者的支持不佳，一旦改变interface所有的实现类都必须同时 修改。如果要修改一个有很多实现类的interface，很容易导致现有的设计陷入瘫痪，以至只好借助有版本的inter -face来调整设计。抽象类没有这方面的限制，只要提供了默认实现，在抽象类中新增的操作就不会侵扰现有的实现 类。抽象类的局限体现在实现类必须对其忠心不二，如果需要以另一种视角来看待同一个实现类，就只能让它实现 interface。
7. 有版本的interface：
8. 值对象：把具有可变状态的对象最为思考计算问题的一种方式确实很有价值，但它并非唯一的方式。当问题可以被归 约到由绝对真实和确定构成的，在其中可以以谈论“永恒真理”的抽象世界，另一种思考这类问题的方式已经发展了数 千年，那就是数学。过程式的接口比函数式的接口更常见，过程式接口的一个问题，是过程调用的顺序成为了接口含 义的重要组成部分，修改这样的程序非常困难，需要格外小心，你可能制作了一点小小的改变，却不留神改变了调用 的顺序，从而破坏了其中隐藏的接口含义，并以此带来意料之外的影响。
9. 特化：清晰的描述计算过程中相似性与差异性的相互作用，可以让程序更容易阅读，使用和修改。在实际工作中，没 有哪段代码是独一无二的。不同程序会表达相似的概念，同样一个程序中的很多部分往往也在表达着相似的概念，清 晰的描述相似性和差异性，就能让阅读者更好的理解现有代码，找出自己想要做的事情是否已经被某种现有的各种实 现所覆盖，以及——如果还没有现成实现——如何对现有代码加以特化或是编写新的代码以满足需求。
10. 子类：声明一个子类就是在说，这些对象与那些对象很类似，只除了……如果有个适当的超类，创建子类会是一种强 大的编程方式，通过覆盖适当的方法，只需几行代码就可以为现有的计算逻辑引入变化。
11. 实现器：在由对象组成的程序中，多态消息是表达选择的基本方法之一，为了让消息能起到选择的作用，能够接收 到该消息的对象就必须不止一种。
12. 内部类：
13. 实例特有的行为：
14. 条件语句：
15. 委派：
16. 可插拔的选择器：
17. 匿名内部类：
18. 库类：

### 个人总结：

前半章主要讲述了基本编程元素类，抽象类，接口，有版本的接口，值对象等，通过类命名这一方面来说明了抽象类 （超类）和具体类之间的异同，类时块业务功能的程序抽象，它的名称应该符合当前的场景，且具有隐喻的效果，让 人们再读到类名的时候就能将他带到应用场景里。接口作为Java里面最高层的抽象，设计建模的时后需要谨慎，只有 在真的需要接口这么高的抽象层次的时候，才去创建对应的接口，一旦接口创建完成，就不能轻易修改，如果真的需 要修改可以使用有版本的接口这种方式来临时处理，Java 8在接口中引入了*default*修饰符，也可以用于这种 情况，但是切记好的设计才是正确的做法，这些方式不过是设计真的出错而修改代价有很大的时候做的折中方案。值 对象是从函数式编程引入的概念，这里需要区分过程式，面向对象以及函数式三种编程风格的区别，理解了这三者的 确别以及适用的场景，才能在需要的时候用正确的风格设计出好的方案。

## 状态

### 读书笔记

本章所介绍的模式用于告诉代码的阅读者，你是如何使用状态的。对象方便的包装了行为（behavior）和状态（state） 前者暴露给外部世界，后者则为前者提供支持。

1. 状态：状态变迁是一个符合现实世界的编程隐喻。有效管理状态的关键在于，把相似的状态放在一起，确保不同的 状态彼此分离。有两条线索指出两个状态的相似性，他们在同一个计算中被用到，他们出现和消亡的时间相同。如果 两个状态总是同时被使用，而且有同样的声明周期，它们就应该被放在一起。
2. 访问：编程语言的二分法之一，就是对“访问存储值”和“执行计算”的区分。存储什么？计算什么？这个问题会影响程序 的可读性，灵活性和性能，有时这些目标会彼此冲突，甚至与你的编程喜好冲突，有时环境会发生变化，于是昨天看起来 合理的“存储-计算”划分现在就不再合理了，做出当下可用的决策，保持在将来改变主意的灵活性，这是做好软件的关键 。对象的功能之一是管理储存空间。每个对象都是一个独立的计算环境拥有自己的一块内存空间，一定程度上与其他计算 环境相隔离。
3. 直接访问：直接访问足够简单，但损失了灵活性。如果对变量使用直接访问进行赋值，就没有任何转圜的余地，如果在多个 地方对同一个变量赋值，那么需要做出改变时就可能必须修改这些地方。另一个缺点，这种操作属于实现细节，其层面 低于编程时通常思考的层面。
4. 间接访问：可以用方法调用来隐藏对状态的访问和修改，这些访问器能带来更好的灵活性，但同时也付出了降低清晰直观 程度的代价。
5. 通用状态：很多计算逻辑会涉及同样的数据项，尽管其中的值可能不同，如果发现这样的一组计算逻辑，为了表达意图， 应该把它们共同的数据项申明为一个类中的字段。比如*Point*用于抽象坐标。一个对象中所有的通用状态应该具有相同的 生命周期，有时我被诱惑着引入一个这样的字段：它只被对象中的一小部分方法使用，或者只在某个方法被调用的过程中有 效，每当遇到这种情况，我总能找到一个更好的地方来保存这部分数据（可能是一个参数或者一个辅助对象），从而改善代 码质量。
6. 可变状态：可变状态比通用状态灵活的多，它最大的问题时表意不清晰，对于只有可变状态的对象，需要哪些数据项才能 让它正常工作？只有仔细阅读代码，甚至观察程序执行后，才能回答这个问题。如果遇到一个字段的状态决定了同一个对象中 是否需要其他字段，这种情况下就应该使用可变状态。如果几个变量有同样的前缀，这可能就意味着应该引入某种辅助对象。
7. 外生状态：有时程序中的某一部分需要与某个对象相关的状态，但系统其他部分并不需要。把这些信息放在对象的字段中会 违反对称原则，因为其他字段是对于整个系统都有用的。对于特殊用途的信息，应该保存在使用该信息的地方，而不是保存在 对象内部。
8. 变量：代码的阅读者需要知道变量的作用域，声明周期，角色和运行时类型，人们发明了种种详尽的变量命名规则来传达所有 这些信息，不过代码中的命名还是以简单为好。
9. 局部变量：局部变量允许访问的范围是从声明点起，至所处的作用域结束处为止。遵照“信息最小扩散”原则，应该在尽可能靠内 的作用域以及在确实需要时才声明局部变量。
10. 字段：字段的作用域和生命周期与其所属的对象相同，由于字段时提供给整个对象使用的，所以应该把它们放在一起，在类的最 前面或者最后面声名。
11. 参数：
12. 收集参数：有时计算逻辑需要从多次方法调用中收集结果，并将这些结果以某种方式合并起来。
13. 可选参数：
14. 变长参数：
15. 参数对象：如果同一组参数被放在一起传递给了很多个方法，就应该考虑创建一个对象，把这些参数放入该对象的字段，然后传递 这个对象。
16. 常量：
17. 按角色命名：名字被读到的次数比写出的次数要多得多，所以在起名时应该更重视可读性，而不是输入的便利，变量名应该 体现变量中的数据会如何被使用，以及这些数据在计算逻辑中扮演什么角色。
18. 声明时的类型：
19. 初始化：
20. 及早初始化：
21. 延迟初始化：

### 个人总结

状态一章，主要讲述了类的变量，以及如何在多个类协作的系统中组织这些变量。最终我们组织这些变量需要达到，清晰明了 的目的，阅读者能够在当前对象中了解到变量的作用，以及这些变量是如何协作工作的。我们还要区分类的字段以及参数， 如果某个变量只在该方法或者中只在对象的局部生命周期中使用到了，就应该声明为参数，如果一个变量参与到对象的多个生命 周期中或者被多个方法同时访问，则考虑将其变为字段。

## 行为

### 读书笔记

冯诺依曼贡献了关于计算的一个重要隐喻：一系列依次执行的指令。

1. 控制流：
2. 主体流：程序员通常心里都会想象一个程序控制流的主干，处理过程从这里开始，到那里结束，一路上会有一些决策 和异常，但整个运算还是有路可循的，要用你的编程语言清晰的表达这个流。
3. 消息：
4. 选择性消息：
5. 双重分发：
6. 分解性消息：
7. 反置性消息：
8. 邀请性消息：
9. 解释性消息：
10. 异常流：
11. 卫述句：
12. 异常：
13. 已检查异常：
14. 异常传播：

### 个人总结

本章前半部分讲述了对象间消息的传播，或者说如何组织对象间的 消息，后半部分描述了异常机制。

## 方法

### 读书笔记

1. 组合方法：通过对其它方法的调用来组合出新的方法，被调用方法应该大致属于相同的抽象层次。组合方法时应 当根据事实而非推测，先让代码正常工作，然后再决定该怎么安排它的结构。
2. 揭示意图的名称：应该从潜在调用者的想法出发，根据调用者使用该方法的意图来给方法命名。
3. 方法可见性：要谨慎的暴露方法，从最严的可见性开始，有必要时再暴露
4. 方法对象：
5. 覆盖方法：
6. 重载方法：
7. 方法返回类型：
8. 方法注释：对于沟通良好的代码来说，很多注释完全是多余的
9. 助手方法：助手方法的目的时通过暂时的隐藏目前不关心的细节，让你得以通过方法的名字来表达意图， 从而令大尺度的运算更具可读性
10. 调试输出方法：如果需要提供便于程序员使用的对象表示，则重载toString()，而其他用途的字符串 表示请放在其他方法或单独的类中
11. 转换：
12. 转换方法：
13. 转换构造器：
14. 创建：
15. 完整的构造器：
16. 工厂方法：
17. 内部工厂：
18. 容器访问器方法：
19. 布尔值setting方法：
20. 查询方法：
21. 相等性判断方法：
22. getting方法：
23. setting方法：
24. 安全副本：

### 个人总结

如何写方法？或者说如何把计算逻辑组织成方法？本章主要讲述了编程时方法相关的一些细节问题。我们 要通过方法来组织计算逻辑，一个方法内相同层次方法应该是相同的计算逻辑。为你的方法取一个符合计算上下文情景 的名字，方法名的表现力远胜详尽的注释。尽量让方法可见性最低，除非这些是转为接口设计的方法。覆盖是用来表达 计算变体的一种清晰方式。重载更多的是表达该方法有多种格式，但平时开发不要刻意的去使用重载，有时一个好的方 法名称才是更可取的。*Object#toString*主要是用来程序系统使用的，业务中的定制化字符串，提供符合业务逻辑的 方法来实现。

## 容器

### 读书笔记

1. 隐喻：多值变量，独立的对象实体，数学集合
2. 要点：
3. 接口：
4. 实现：

Java中的结合接口：

- Array，数组，大小固定，访问方法简单，速度快
- Iterable，迭代器，容器通过迭代器来迭代集合中的元素
- Collection，提供了元素的添加，删除和测试功能
- List，容器中的元素是有序的，可以通过下标来访问
- Set，没有重复元素的容器
- SortedSet，没有重复元素的有序容器
- Map，通过键来存取元素的容器

### 个人总结

Java中集合的使用以及它们实现的性能上的对比，其中使用集合的高层抽象而不是具体实现需要注意

## 改进框架

### 读书笔记

1. 修改框架而不修改应用
2. 不兼容的更新
3. 鼓励可兼容的变化

### 我的总结

没有开发过什么框架，但其中一些描述也很适用于提供API接口这种服务开发模式